<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Strategic Play Chess Game Created By NifftySwiggle</title>
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: Arial, sans-serif; }
    #chessboard { width: 400px; height: 400px; border: 2px solid #333; }
    #promotionModal, #onlineMenuModal { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.5); }
    .modal-content { text-align: center; }
    .piece-option { cursor: pointer; margin: 0 10px; width: 50px; height: 50px; }
    .piece-option:hover { transform: scale(1.1); }
    #gameList { max-height: 200px; overflow-y: auto; }
    .game-item { cursor: pointer; padding: 10px; border-bottom: 1px solid #ddd; }
    .game-item:hover { background-color: #f0f0f0; }
  </style>
</head>
<body class="bg-gray-100 flex flex-col items-center p-4">
  <h1 class="text-4xl font-bold mb-4">Strategic Play Chess Game</h1>
  <div class="flex flex-col md:flex-row gap-4 w-full max-w-4xl">
    <div id="boardContainer" class="flex justify-center">
      <div id="chessboard"></div>
    </div>
    <div class="flex flex-col gap-4">
      <div id="gameControls" class="bg-white p-4 rounded shadow">
        <h2 class="text-xl font-semibold mb-2">Game Modes</h2>
        <button id="newGameBtn" class="bg-blue-500 text-white px-4 py-2 rounded mb-2 w-full hover:bg-blue-600">New Game (vs Computer)</button>
        <button id="localMultiplayerBtn" class="bg-green-500 text-white px-4 py-2 rounded mb-2 w-full hover:bg-green-600">Local Multiplayer</button>
        <button id="onlineMultiplayerBtn" class="bg-purple-500 text-white px-4 py-2 rounded mb-2 w-full hover:bg-purple-600">Online Multiplayer</button>
        <button id="puzzleModeBtn" class="bg-yellow-500 text-white px-4 py-2 rounded mb-2 w-full hover:bg-yellow-600">Puzzle Mode</button>
        <button id="tournamentBtn" class="bg-red-500 text-white px-4 py-2 rounded w-full hover:bg-red-600">Tournament (Coming Soon)</button>
      </div>
      <div id="gameInfo" class="bg-white p-4 rounded shadow">
        <h2 class="text-xl font-semibold mb-2">Game Info</h2>
        <p id="status" class="mb-2">Select a game mode to start</p>
        <p id="turn" class="mb-2">Turn: White</p>
        <p id="fen" class="mb-2 text-sm">FEN: rnbqkbnr/pppppppp/5n5/4p3/4P3/5N5/PPPP1PPP/RNBQKB1R w KQkq - 0 1</p>
        <p id="pgn" class="text-sm">PGN: </p>
      </div>
      <div id="tournamentInfo" class="bg-white p-4 rounded shadow hidden">
        <h2 class="text-xl font-semibold mb-2">Tournament (Coming Soon)</h2>
        <p id="tournamentStatus">No active tournament</p>
        <button id="createTournamentBtn" class="bg-blue-500 text-white px-4 py-2 rounded mt-2 w-full hover:bg-blue-600">Create Tournament</button>
      </div>
    </div>
  </div>
  <div id="promotionModal" class="modal-content">
    <h2 class="text-lg font-semibold mb-4">Promote Pawn</h2>
    <img src="https://dweb.link/ipfs/QmWNXu55MadCNJEx6CZiTypE1FespiktahQo1CgSMJMrd7" class="piece-option" data-piece="q" alt="Queen">
    <img src="https://dweb.link/ipfs/QmWHGn4ot4h5adR2qsMexpKECcoGkZZQxVVYMykwu2dUsh" class="piece-option" data-piece="r" alt="Rook">
    <img src="https://dweb.link/ipfs/QmZH7BKMRKDmvEoAv7TumRUPSgHXPbAbexULqXCF5zx8BS" class="piece-option" data-piece="b" alt="Bishop">
    <img src="https://dweb.link/ipfs/QmZ1X9bZx3q3X5q3X5q3X5q3X5q3X5q3X5q3X5q3X5q3X" class="piece-option" data-piece="n" alt="Knight">
  </div>
  <div id="onlineMenuModal" class="modal-content">
    <h2 class="text-lg font-semibold mb-4">Online/Tournament Games</h2>
    <label for="presetSelect">Choose time control:</label>
    <select id="presetSelect">
    <option value="3-0">Blitz (3|0)</option>
    <option value="5-2">Rapid (5|2)</option>
    <option value="10-5">Classical (10|5)</option>
    </select>
    <button id="createGameBtn" class="bg-blue-500 text-white px-4 py-2 rounded mb-2 w-full hover:bg-blue-600">Create New Game</button>
    <button id="createTournamentGameBtn" class="bg-red-500 text-white px-4 py-2 rounded mb-2 w-full hover:bg-red-600">Create New Tournament</button>
    <h3 class="text-md font-semibold mt-4">Available Games</h3>
  <div id="gameList" class="mt-2"></div>
    <button id="closeMenuBtn" class="bg-gray-500 text-white px-4 py-2 rounded mt-4 w-full hover:bg-gray-600">Close</button>
    </div>

<script>
let chess = new Chess();
let board = null;
let gameMode = null;
let playerColor = 'w';
let ws = null;
let gameId = null;
let puzzleMode = false;
let currentPuzzle = null;
let puzzles = [];
let tournamentActive = false;
let tournamentId = null;
let gameStarted = false;
let pendingMove = null;
let availableGames = [];

// Commenting out sound initialization to avoid file extension error
// const moveSound = new Howl({ src: [''] });
// const captureSound = new Howl({ src: [''] });
// const checkSound = new Howl({ src: [''] });

document.addEventListener('DOMContentLoaded', function() {
  try {
    console.log('Initializing Chessboard.js');
    board = Chessboard('chessboard', {
      draggable: true,
      dropOffBoard: 'snapback',
      position: 'start',
      pieceTheme: 'https://dweb.link/ipfs/QmfNa6dcLWRnur3PPWmXwDhkrpfnuRR5NF5Cs9DnwKdV5d/{piece}.png',
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd
    });

    // Attempt to load puzzles, with fallback
    fetch('./puzzles.json')
      .then(response => {
        if (!response.ok) {
          throw new Error('Failed to fetch puzzles.json');
        }
        return response.json();
      })
      .then(data => {
        puzzles = data;
        console.log('Puzzles loaded:', puzzles.length);
      })
      .catch(err => {
        console.error('Failed to load puzzles:', err);
        puzzles = []; // Ensure puzzles array is empty
        $('#status').text('Failed to load puzzles. Puzzle mode unavailable.');
      });

    setupEventListeners();
    updateGameInfo();
  } catch (err) {
    console.error('Initialization failed:', err);
  }
});

function onDragStart(source, piece, position, orientation) {
  try {
    if (!gameStarted) {
      console.log('Drag prevented: Game not started. Select a game mode.');
      return false;
    }
    // Restrict moves in online/tournament to assigned color and only on your turn
    if ((gameMode === 'online' || gameMode === 'tournament')) {
      if (chess.turn() !== playerColor) {
        console.log('Drag prevented: Not your turn.', chess.turn(), playerColor);
        return false;
      }
      if (piece[0] !== playerColor) {
        console.log('Drag prevented: Not your piece.', piece, playerColor);
        return false;
      }
    }
    // Puzzle mode: only allow moving if it's your turn
    if (puzzleMode && chess.turn() !== playerColor) {
      console.log('Drag prevented: Not your turn in puzzle mode:', chess.turn());
      return false;
    }
    // Computer/local: only allow moving your own pieces
    if ((gameMode === 'computer' || gameMode === 'local') && piece[0] !== chess.turn()) {
      console.log('Drag prevented: Not your piece or turn:', piece, chess.turn());
      return false;
    }
    return true;
  } catch (err) {
    console.error('onDragStart failed:', err);
    return false;
  }
}

function onDrop(source, target, piece) {
  try {
    if (target === 'offboard') {
      console.log('Invalid drop: Off board');
      return 'snapback';
    }
    let move = {
      from: source,
      to: target,
      promotion: 'q' // Default promotion
    };
    let legalMoves = chess.moves({ square: source, verbose: true });
    console.log('Legal moves for', source, ':', legalMoves);
    let legalMove = legalMoves.find(m => m.to === target);
    if (legalMove) {
      console.log('Attempting move:', move);
      if (legalMove.flags.includes('p')) {
        pendingMove = move;
        showPromotionModal();
        return; // Defer move until promotion is selected
      } else {
        return makeMove(move);
      }
    } else {
      console.log('Invalid move:', move, 'Legal moves:', legalMoves);
      return 'snapback';
    }
  } catch (err) {
    console.error('onDrop failed:', err);
    return 'snapback';
  }
}

function onSnapEnd() {
  try {
    if (!pendingMove) {
      board.position(chess.fen());
      console.log('Board updated after snap:', chess.fen());
    }
  } catch (err) {
    console.error('onSnapEnd failed:', err);
  }
}

function makeMove(move) {
  try {
    let result = chess.move(move);
    if (result) {
      console.log('Move successful:', result);
      board.position(chess.fen());
      updateGameInfo();
      // playSound(result); // Commented out to avoid sound-related errors
      if (gameMode === 'online' || gameMode === 'tournament') {
        ws.send(JSON.stringify({ type: 'move', gameId, move }));
      }
      if (gameMode === 'computer' && !chess.game_over() && chess.turn() !== playerColor) {
        setTimeout(computerMove, 500);
      }
      if (puzzleMode) {
        checkPuzzleMove(result);
      }
      return;
    } else {
      console.log('Move failed:', move);
      return 'snapback';
    }
  } catch (err) {
    console.error('makeMove failed:', err);
    return 'snapback';
  }
}

// function playSound(move) {
//   try {
//     if (move.flags.includes('c') || move.flags.includes('e')) {
//       captureSound.play();
//     } else if (chess.in_check()) {
//       checkSound.play();
//     } else {
//       moveSound.play();
//     }
//   } catch (err) {
//     console.error('playSound failed:', err);
//   }
// }

function computerMove() {
  try {
    let moves = chess.moves({ verbose: true });
    let bestMove = minimax(chess, 3, -Infinity, Infinity, true).move;
    chess.move(bestMove);
    board.position(chess.fen());
    updateGameInfo();
    // playSound(bestMove); // Commented out to avoid sound-related errors
  } catch (err) {
    console.error('computerMove failed:', err);
  }
}

function minimax(chess, depth, alpha, beta, maximizing) {
  try {
    if (depth === 0 || chess.game_over()) {
      return { score: evaluateBoard(chess) };
    }
    let moves = chess.moves({ verbose: true });
    if (maximizing) {
      let best = { score: -Infinity };
      for (let move of moves) {
        chess.move(move);
        let result = minimax(chess, depth - 1, alpha, beta, false);
        chess.undo();
        if (result.score > best.score) {
          best = { score: result.score, move };
        }
        alpha = Math.max(alpha, result.score);
        if (beta <= alpha) break;
      }
      return best;
    } else {
      let best = { score: Infinity };
      for (let move of moves) {
        chess.move(move);
        let result = minimax(chess, depth - 1, alpha, beta, true);
        chess.undo();
        if (result.score < best.score) {
          best = { score: result.score, move };
        }
        beta = Math.min(beta, result.score);
        if (beta <= alpha) break;
      }
      return best;
    }
  } catch (err) {
    console.error('minimax failed:', err);
    return { score: 0 };
  }
}

function evaluateBoard(chess) {
  try {
    let score = 0;
    let pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
    for (let i = 0; i < 8; i++) {
      for (let j = 0; j < 8; j++) {
        let square = String.fromCharCode(97 + j) + (8 - i);
        let piece = chess.get(square);
        if (piece) {
          let value = pieceValues[piece.type];
          score += piece.color === 'w' ? value : -value;
        }
      }
    }
    return score;
  } catch (err) {
    console.error('evaluateBoard failed:', err);
    return 0;
  }
}

function showPromotionModal() {
  try {
    $('#promotionModal').show();
    $('.piece-option').off('click').on('click', function() {
      if (pendingMove) {
        pendingMove.promotion = $(this).data('piece');
        let result = makeMove(pendingMove);
        if (result !== 'snapback') {
          $('#promotionModal').hide();
          pendingMove = null;
        }
      }
    });
  } catch (err) {
    console.error('showPromotionModal failed:', err);
  }
}

function updateGameInfo() {
  try {
    let status = gameStarted ? '' : 'Select a game mode to start';
    if (gameStarted) {
      if (chess.in_checkmate()) {
        status = `Checkmate! ${chess.turn() === 'w' ? 'Black' : 'White'} wins!`;
      } else if (chess.in_check()) {
        status = 'Check!';
      } else if (chess.in_draw()) {
        status = 'Draw!';
      } else {
        status = `${chess.turn() === 'w' ? 'White' : 'Black'} to move`;
      }
    }
    $('#status').text(status);
    $('#turn').text(`Turn: ${chess.turn() === 'w' ? 'White' : 'Black'}`);
    $('#fen').text(`FEN: ${chess.fen()}`);
    $('#pgn').text(`PGN: ${chess.pgn()}`);
  } catch (err) {
    console.error('updateGameInfo failed:', err);
  }
}

function showOnlineMenu() {
  try {
    $('#onlineMenuModal').show();
    updateGameList();
  } catch (err) {
    console.error('showOnlineMenu failed:', err);
  }
}

function updateGameList() {
  try {
    $('#gameList').empty();
    availableGames.forEach(game => {
      let gameType = game.isTournament ? 'Tournament' : 'Online Game';
      let item = $(`<div class="game-item" data-game-id="${game.id}">${gameType} ${game.id} - ${game.players} player(s)</div>`);
      item.click(() => joinGame(game.id, game.isTournament));
      $('#gameList').append(item);
    });
  } catch (err) {
    console.error('updateGameList failed:', err);
  }
}

function joinGame(id, isTournament) {
  try {
    gameMode = isTournament ? 'tournament' : 'online';
    gameStarted = true;
    ws.send(JSON.stringify({ type: 'joinGame', gameId: id, isTournament }));
    $('#onlineMenuModal').hide();
    if (isTournament) {
      $('#tournamentInfo').removeClass('hidden');
      $('#tournamentStatus').text(`Joined Tournament ${id}`);
    }
  } catch (err) {
    console.error('joinGame failed:', err);
  }
}

function setupEventListeners() {
  try {
    $('#newGameBtn').click(() => {
      chess.reset();
      gameMode = 'computer';
      playerColor = 'w';
      gameStarted = true;
      board.position('start');
      updateGameInfo();
      $('#tournamentInfo').addClass('hidden');
      $('#onlineMenuModal').hide();
    });

    $('#localMultiplayerBtn').click(() => {
      chess.reset();
      gameMode = 'local';
      gameStarted = true;
      board.position('start');
      updateGameInfo();
      $('#tournamentInfo').addClass('hidden');
      $('#onlineMenuModal').hide();
    });

    $('#onlineMultiplayerBtn').click(() => {
      connectWebSocket();
      showOnlineMenu();
    });

    $('#puzzleModeBtn').click(() => {
      if (puzzles.length === 0) {
        $('#status').text('Puzzle mode unavailable: No puzzles loaded.');
        return;
      }
      gameStarted = true;
      startPuzzleMode();
      $('#onlineMenuModal').hide();
    });

    $('#tournamentBtn').click(() => {
      connectWebSocket();
      showOnlineMenu();
    });

    $('#createGameBtn').click(() => {
      const [minutes, increment] = $('#presetSelect').val().split('-').map(Number);
      if (ws) {
        ws.send(JSON.stringify({ 
          type: 'createGame', 
          isTournament: false,
          timeControl: { minutes, increment }
         }));
      }
    });

    $('#createTournamentGameBtn').click(() => {
      const [minutes, increment] = $('#presetSelect').val().split('-').map(Number);
      if (ws) {
        ws.send(JSON.stringify({ 
          type: 'createTournament',
          isTournament: true,
          timeControl: { minutes, increment },
        }));
      }
    });

    $('#createTournamentBtn').click(() => {
      if (ws) {
        ws.send(JSON.stringify({ type: 'createTournament' }));
      }
    });

    $('#closeMenuBtn').click(() => {
      $('#onlineMenuModal').hide();
    });
  } catch (err) {
    console.error('setupEventListeners failed:', err);
  }
}

function startPuzzleMode() {
  try {
    puzzleMode = true;
    if (puzzles.length > 0) {
      currentPuzzle = puzzles[Math.floor(Math.random() * puzzles.length)];
      chess.load(currentPuzzle.fen);
      playerColor = chess.turn();
      board.position(currentPuzzle.fen);
      updateGameInfo();
      $('#status').text(`Puzzle: Find the best move for ${playerColor === 'w' ? 'White' : 'Black'}`);
    } else {
      console.warn('No puzzles available');
      $('#status').text('No puzzles available. Select another mode.');
      puzzleMode = false;
      gameStarted = false;
    }
  } catch (err) {
    console.error('startPuzzleMode failed:', err);
    $('#status').text('Error starting puzzle mode. Select another mode.');
  }
}

function checkPuzzleMove(move) {
  try {
    if (move.san === currentPuzzle.solution) {
      $('#status').text('Correct! Loading next puzzle...');
      setTimeout(startPuzzleMode, 2000);
    } else {
      $('#status').text('Incorrect. Try again.');
      chess.undo();
      board.position(chess.fen());
    }
  } catch (err) {
    console.error('checkPuzzleMove failed:', err);
  }
}

function connectWebSocket() {
  try {
    if (ws && ws.readyState === WebSocket.OPEN) {
      return;
    }
    ws = new WebSocket('wss://game-hub-fnqa.onrender.com');
    ws.onopen = () => {
      console.log('Connected to WebSocket server');
      ws.send(JSON.stringify({ type: 'fetchLobby' })); // <-- change here
    };
    ws.onmessage = (event) => {
      try {
        let data = JSON.parse(event.data);
        console.log('WebSocket message:', data);
        if (data.type === 'gameCreated') {
          gameId = data.gameId;
          playerColor = data.color;
          chess.reset();
          board.position('start');
          updateGameInfo();
          $('#onlineMenuModal').hide();
          $('#status').text(`Game ${gameId} created. Waiting for opponent...`);
        } else if (data.type === 'tournamentCreated') {
          tournamentId = data.tournamentId;
          tournamentActive = true;
          gameId = data.tournamentId;
          chess.reset();
          board.position('start');
          updateGameInfo();
          $('#tournamentInfo').removeClass('hidden');
          $('#tournamentStatus').text(`Tournament ${tournamentId} created. Waiting for players...`);
          $('#onlineMenuModal').hide();
        } else if (data.type === 'opponentJoined' || data.type === 'gameStarted' || data.type === 'gameStart') {
          gameId = data.gameId;
          playerColor = data.color || playerColor; // Only set if provided
          chess.reset();
          board.position('start');
          updateGameInfo();
          $('#status').text(`Game ${gameId} started. You play ${playerColor === 'w' ? 'White' : 'Black'}.`);
        } else if (data.type === 'move') {
          chess.move(data.move);
          board.position(chess.fen());
          updateGameInfo();
          // playSound(data.move); // Commented out to avoid sound-related errors
        } else if (data.type === 'availableGames' || data.type === 'lobbyData'  ) {
          availableGames = data.games.map(game => ({
            id: game.id,
            players: game.players,
            isTournament: game.isTournament || false,
            timeControl: game.timeControl
          }));
            availableTournaments = data.tournaments.map(t => ({
            id: t.id,
            name: t.name,
            players: t.players
          }));
          updateGameList();
          updateTournamentList();
        } else if (data.type === 'opponentDisconnected') {
          $('#status').text('Opponent disconnected. Game ended.');
          gameStarted = false;
        }
      } catch (err) {
        console.error('WebSocket message handling failed:', err);
      }
    };
    ws.onclose = () => {
      console.log('Disconnected from WebSocket server');
      $('#status').text('Disconnected from server. Please refresh.');
    };
    ws.onerror = (err) => {
      console.error('WebSocket error:', err);
      $('#status').text('WebSocket error. Please refresh.');
    };
  } catch (err) {
    console.error('connectWebSocket failed:', err);
  }
}
</script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96226dd19a8fa811',t:'MTc1MzAxNDE5OC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
