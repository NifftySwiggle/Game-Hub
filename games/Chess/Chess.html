<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Strategic Play Chess Game Created By NifftySwiggle</title>
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      min-height: 100vh; 
      display: flex; 
      flex-direction: column; 
      justify-content: center; 
      align-items: center; 
      margin: 0; 
      background-color: #f3f4f6; 
    }
    #boardContainer { 
      width: 100%; 
      max-width: min(50vw, 500px);
      height: auto; 
      aspect-ratio: 1 / 1; 
      display: flex; 
      justify-content: center; 
      margin: 0 auto;
      touch-action: none;
    }
    #chessboard { 
      width: 100%; 
      max-width: min(50vw, 500px);
      height: auto; 
      aspect-ratio: 1 / 1; 
      border: none; 
    }
    #gameControls, #tournamentInfo {
      width: 100%;
      max-width: 300px;
    }
    #gameInfo {
      background: white;
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      margin-top: 10px;
      text-align: center;
      width: 100%;
      max-width: min(50vw, 500px);
    }
    #promotionModal, #onlineMenuModal, #tournamentModal { 
      display: none; 
      position: fixed; 
      max-height: 80vh; 
      overflow-y: auto; 
      top: 50%; 
      left: 50%; 
      transform: translate(-50%, -50%); 
      background: white; 
      padding: 20px; 
      border-radius: 8px; 
      box-shadow: 0 0 10px rgba(0,0,0,0.5); 
      width: 90%; 
      max-width: min(500px, 90vw);
    }
    .modal-content { text-align: center; }
    .piece-option { cursor: pointer; margin: 0 10px; width: 50px; height: 50px; }
    .piece-option:hover { transform: scale(1.1); }
    #gameList, #tournamentList { max-height: 200px; overflow-y: auto; }
    .game-item { cursor: pointer; padding: 10px; border-bottom: 1px solid #ddd; }
    .game-item:hover { background-color: #f0f0f0; }
    #pieceThemeSelect { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd; }
    .form-label { display: block; text-align: left; font-weight: bold; margin-bottom: 4px; }
    .main-container {
      width: 100%;
      max-width: min(1200px, 95vw);
      margin: 0 auto;
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: flex-start;
      gap: 16px;
      flex-wrap: wrap;
    }
    @media (max-width: 768px) {
      .main-container {
        flex-direction: column;
        align-items: center;
      }
      #boardContainer, #chessboard { 
        max-width: min(90vw, 400px);
        min-width: 320px;
      }
      #gameInfo { 
        max-width: min(90vw, 400px);
      }
      #gameControls, #tournamentInfo { 
        max-width: 360px;
      }
    }
    footer {
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h1 class="text-4xl font-bold mb-4">Strategic Play Chess Game</h1>
  <div class="main-container">
    <div class="flex flex-col items-center">
      <div id="boardContainer">
        <div id="chessboard"></div>
      </div>
      <div id="gameInfo" class="bg-white p-4 rounded shadow">
        <p id="status" class="mb-2 font-semibold">Select a game mode to start</p>
        <p id="playerColor" class="mb-2">Your Color: White</p>
        <p id="turn" class="mb-2">Turn: White</p>
        <p id="whiteTimer" class="mb-2">White: 10:00</p>
        <p id="blackTimer" class="mb-2">Black: 10:00</p>
      </div>
    </div>
    <div class="flex flex-col gap-4">
      <div id="gameControls" class="bg-white p-4 rounded shadow">
        <h2 class="text-xl font-semibold mb-2">Game Modes</h2>
        <button id="newGameBtn" class="bg-blue-500 text-white px-4 py-2 rounded mb-2 w-full hover:bg-blue-600">New Game (vs Computer)</button>
        <button id="localMultiplayerBtn" class="bg-green-500 text-white px-4 py-2 rounded mb-2 w-full hover:bg-green-600">Local Multiplayer</button>
        <button id="onlineMultiplayerBtn" class="bg-purple-500 text-white px-4 py-2 rounded mb-2 w-full hover:bg-purple-600">Online Multiplayer</button>
        <button id="puzzleModeBtn" class="bg-yellow-500 text-white px-4 py-2 rounded mb-2 w-full hover:bg-yellow-600">Puzzle Mode</button>
        <button id="tournamentBtn" class="bg-red-500 text-white px-4 py-2 rounded w-full hover:bg-red-600">Tournament</button>
        <h2 class="text-xl font-semibold mb-2 mt-4">Piece Theme</h2>
        <select id="pieceThemeSelect" class="mb-2">
          <option value="standard" selected>Standard</option>
          <option value="custom">Origins</option>
          <option value="unicode">Unicode</option>
          <option value="merida">Soon</option>
        </select>
      </div>
      <div id="tournamentInfo" class="bg-white p-4 rounded shadow hidden">
        <h2 class="text-xl font-semibold mb-2">Tournament Information</h2>
        <p id="tournamentStatus">No active tournament</p>
      </div>
    </div>
  </div>
  <div id="promotionModal" class="modal-content">
    <h2 class="text-lg font-semibold mb-4">Promote Pawn</h2>
    <img src="./assets/origins/bQ.png" class="piece-option" data-piece="q" alt="Queen">
    <img src="./assets/origins/bR.png" class="piece-option" data-piece="r" alt="Rook">
    <img src="./assets/origins/bB.png" class="piece-option" data-piece="b" alt="Bishop">
    <img src="./assets/origins/bK.png" class="piece-option" data-piece="n" alt="Knight">
  </div>
  <div id="onlineMenuModal" class="modal-content">
    <h2 class="text-lg font-semibold mb-4">Online Games</h2>
    <label for="presetSelect">Choose time control:</label>
    <select id="presetSelect">
      <option value="3-0">Blitz (3|0)</option>
      <option value="5-2">Rapid (5|2)</option>
      <option value="10-5">Classical (10|5)</option>
    </select>
    <button id="createGameBtn" class="bg-blue-500 text-white px-4 py-2 rounded mt-2 mb-2 w-full hover:bg-blue-600">Create New Game</button>
    <h3 class="text-md font-semibold mt-4">Available Games</h3>
    <div id="gameList" class="mt-2"></div>
    <h3 class="text-md font-semibold mt-4">Active Tournaments</h3>
    <div id="tournamentList" class="mt-2"></div>
    <button id="closeMenuBtn" class="bg-gray-500 text-white px-4 py-2 rounded mt-4 w-full hover:bg-gray-600">Close</button>
  </div>
  <div id="tournamentModal" class="modal-content">
    <h2 class="text-lg font-semibold mb-4">Create Tournament</h2>
    <form id="createTournamentForm" class="mb-4">
      <label for="tournamentName" class="form-label">Tournament Name</label>
      <input type="text" id="tournamentName" placeholder="Enter tournament name" class="w-full p-2 mb-3 border rounded" required>
      <label for="tournamentRounds" class="form-label">Number of Rounds</label>
      <input type="number" id="tournamentRounds" placeholder="Enter number of rounds" class="w-full p-2 mb-3 border rounded" min="1" value="3" required>
      <label for="tournamentMinutes" class="form-label">Minutes per Player</label>
      <input type="number" id="tournamentMinutes" placeholder="Enter minutes per player" class="w-full p-2 mb-3 border rounded" min="1" value="10" required>
      <label for="tournamentIncrement" class="form-label">Increment (Seconds)</label>
      <input type="number" id="tournamentIncrement" placeholder="Enter increment in seconds" class="w-full p-2 mb-3 border rounded" min="0" value="0" required>
      <button type="submit" class="bg-red-500 text-white px-4 py-2 rounded w-full hover:bg-red-600">Create Tournament</button>
    </form>
    <button id="closeTournamentModalBtn" class="bg-gray-500 text-white px-4 py-2 rounded w-full hover:bg-gray-600">Close</button>
  </div>

<script>
let chess = new Chess();
let board = null;
let gameMode = null;
let playerColor = 'w';
let ws = null;
let gameId = null;
let puzzleMode = false;
let currentPuzzle = null;
let puzzles = [];
let tournamentActive = false;
let tournamentId = null;
let gameStarted = false;
let pendingMove = null;
let availableGames = [];
let touchStartSquare = null;
let touchPiece = null;
let whiteTime = 600;
let blackTime = 600;
let timeIncrement = 0;
let timerInterval = null;
let currentTurn = 'w';

const pieceThemes = {
  unicode: (piece) => {
    const unicodePieces = {
      'wK': '♔', 'wQ': '♕', 'wR': '♖', 'wB': '♗', 'wN': '♘', 'wP': '♙',
      'bK': '♚', 'bQ': '♛', 'bR': '♜', 'bB': '♝', 'bN': '♞', 'bP': '♟'
    };
    const canvas = document.createElement('canvas');
    canvas.width = 80;
    canvas.height = 80;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 80, 80);
    ctx.fillStyle = '#000000';
    ctx.font = '60px DejaVu Sans, Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(unicodePieces[piece], 40, 40);
    return canvas.toDataURL();
  },
  custom: (piece) => `./assets/origins/${piece}.png`,
  standard: (piece) => `./assets/standard/${piece}.png`,
  merida: (piece) => {
    const pieceMap = {
      'wK': 'Chess_klt45.svg', 'wQ': 'Chess_qlt45.svg', 'wR': 'Chess_rlt45.svg',
      'wB': 'Chess_blt45.svg', 'wN': 'Chess_nlt45.svg', 'wP': 'Chess_plt45.svg',
      'bK': 'Chess_kdt45.svg', 'bQ': 'Chess_qdt45.svg', 'bR': 'Chess_rdt45.svg',
      'bB': 'Chess_bdt45.svg', 'bN': 'Chess_ndt45.svg', 'bP': 'Chess_pdt45.svg'
    };
    return `https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/${pieceMap[piece]}/80px-${pieceMap[piece]}`;
  }
};

document.addEventListener('DOMContentLoaded', function() {
  try {
    console.log('Initializing Chessboard.js');
    board = Chessboard('chessboard', {
      draggable: true,
      dropOffBoard: 'snapback',
      position: 'start',
      pieceTheme: pieceThemes.standard,
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd
    });
    board.resize();
    window.addEventListener('resize', () => board.resize());

    const boardElement = document.getElementById('chessboard');
    boardElement.addEventListener('touchstart', handleTouchStart, { passive: false });
    boardElement.addEventListener('touchmove', handleTouchMove, { passive: false });
    boardElement.addEventListener('touchend', handleTouchEnd, { passive: false });

    fetch('./puzzles.json')
      .then(response => {
        if (!response.ok) throw new Error('Failed to fetch puzzles.json');
        return response.json();
      })
      .then(data => {
        puzzles = data;
        console.log('Puzzles loaded:', puzzles.length);
      })
      .catch(err => {
        console.error('Failed to load puzzles:', err);
        puzzles = [];
        $('#status').text('Failed to load puzzles. Puzzle mode unavailable.');
      });

    setupEventListeners();
    updateGameInfo();
  } catch (err) {
    console.error('Initialization failed:', err);
  }
});

function formatTime(seconds) {
  const min = Math.floor(seconds / 60);
  const sec = Math.floor(seconds % 60);
  return `${min}:${sec < 10 ? '0' : ''}${sec}`;
}

function startTimer() {
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    if (!gameStarted || chess.game_over()) {
      clearInterval(timerInterval);
      return;
    }
    if (currentTurn === 'w') {
      whiteTime = Math.max(0, whiteTime - 1);
      if (whiteTime === 0) {
        $('#status').text('Time out! Black wins!');
        clearInterval(timerInterval);
        gameStarted = false;
      }
    } else {
      blackTime = Math.max(0, blackTime - 1);
      if (blackTime === 0) {
        $('#status').text('Time out! White wins!');
        clearInterval(timerInterval);
        gameStarted = false;
      }
    }
    updateGameInfo();
  }, 1000);
}

function getSquareFromEvent(event) {
  try {
    const boardElement = document.getElementById('chessboard');
    const rect = boardElement.getBoundingClientRect();
    const squareSize = rect.width / 8;
    let clientX, clientY;

    if (event.type.startsWith('touch')) {
      const touch = event.changedTouches[0];
      clientX = touch.clientX;
      clientY = touch.clientY;
    } else {
      clientX = event.clientX;
      clientY = event.clientY;
    }

    const x = Math.floor((clientX - rect.left) / squareSize);
    const y = Math.floor((clientY - rect.top) / squareSize);
    if (x < 0 || x > 7 || y < 0 || y > 7) return null;

    const file = String.fromCharCode(97 + x);
    const rank = 8 - y;
    return file + rank;
  } catch (err) {
    console.error('getSquareFromEvent error:', err);
    return null;
  }
}

function handleTouchStart(event) {
  try {
    event.preventDefault();
    const square = getSquareFromEvent(event);
    if (!square) return;

    const piece = chess.get(square);
    if (!piece) return;

    touchPiece = piece.color + piece.type;
    touchStartSquare = square;

    if (!onDragStart(square, touchPiece, chess.fen(), board.orientation())) {
      touchPiece = null;
      touchStartSquare = null;
    }
  } catch (err) {
    console.error('handleTouchStart error:', err);
  }
}

function handleTouchMove(event) {
  event.preventDefault();
}

function handleTouchEnd(event) {
  try {
    event.preventDefault();
    if (!touchStartSquare || !touchPiece) return;

    const targetSquare = getSquareFromEvent(event);
    if (!targetSquare || targetSquare === touchStartSquare) {
      touchStartSquare = null;
      touchPiece = null;
      return;
    }

    const result = onDrop(touchStartSquare, targetSquare, touchPiece);
    if (result !== 'snapback') {
      onSnapEnd();
    }

    touchStartSquare = null;
    touchPiece = null;
  } catch (err) {
    console.error('handleTouchEnd error:', err);
  }
}

function onDragStart(source, piece, position, orientation) {
  try {
    if (!gameStarted) {
      console.log('Drag prevented: Game not started.');
      return false;
    }
    if ((gameMode === 'online' || gameMode === 'tournament')) {
      if (chess.turn() !== playerColor) {
        console.log('Drag prevented: Not your turn.', chess.turn(), playerColor);
        return false;
      }
      if (piece[0] !== playerColor) {
        console.log('Drag prevented: Not your piece.', piece, playerColor);
        return false;
      }
    }
    if (puzzleMode && chess.turn() !== playerColor) {
      console.log('Drag prevented: Not your turn in puzzle mode:', chess.turn());
      return false;
    }
    if ((gameMode === 'computer' || gameMode === 'local') && piece[0] !== chess.turn()) {
      console.log('Drag prevented: Not your piece or turn:', piece, chess.turn());
      return false;
    }
    return true;
  } catch (err) {
    console.error('onDragStart error:', err);
    return false;
  }
}

function onDrop(source, target, piece) {
  try {
    if (target === 'offboard') {
      console.log('Invalid drop: Off board');
      return 'snapback';
    }
    let move = { from: source, to: target, promotion: 'q' };
    let legalMoves = chess.moves({ square: source, verbose: true });
    console.log('Legal moves for', source, ':', legalMoves);
    let legalMove = legalMoves.find(m => m.to === target);
    if (legalMove) {
      console.log('Attempting move:', move);
      if (legalMove.flags.includes('p')) {
        pendingMove = move;
        showPromotionModal();
        return;
      } else {
        return makeMove(move);
      }
    } else {
      console.log('Invalid move:', move, 'Legal moves:', legalMoves);
      return 'snapback';
    }
  } catch (err) {
    console.error('onDrop error:', err);
    return 'snapback';
  }
}

function onSnapEnd() {
  try {
    if (!pendingMove) {
      board.position(chess.fen());
      console.log('Board updated after snap:', chess.fen());
    }
  } catch (err) {
    console.error('onSnapEnd error:', err);
  }
}

function makeMove(move) {
  try {
    let result = chess.move(move);
    if (result) {
      console.log('Move successful:', result);
      board.position(chess.fen());
      currentTurn = chess.turn();
      if (gameMode === 'online' || gameMode === 'tournament') {
        ws.send(JSON.stringify({ type: 'move', gameId, move }));
      } else {
        if (currentTurn === 'w') {
          whiteTime += timeIncrement;
        } else {
          blackTime += timeIncrement;
        }
        if ((gameMode === 'computer' || gameMode === 'local') && !puzzleMode) {
          startTimer();
        }
      }
      if (gameMode === 'computer' && !chess.game_over() && chess.turn() !== playerColor) {
        setTimeout(computerMove, 500);
      }
      if (puzzleMode) checkPuzzleMove(result);
      updateGameInfo();
      return;
    } else {
      console.log('Move failed:', move);
      return 'snapback';
    }
  } catch (err) {
    console.error('makeMove error:', err);
    return 'snapback';
  }
}

function computerMove() {
  try {
    let moves = chess.moves({ verbose: true });
    let bestMove = minimax(chess, 3, -Infinity, Infinity, true).move;
    chess.move(bestMove);
    board.position(chess.fen());
    currentTurn = chess.turn();
    blackTime += timeIncrement;
    startTimer();
    updateGameInfo();
  } catch (err) {
    console.error('computerMove error:', err);
  }
}

function minimax(chess, depth, alpha, beta, maximizing) {
  try {
    if (depth === 0 || chess.game_over()) {
      return { score: evaluateBoard(chess) };
    }
    let moves = chess.moves({ verbose: true });
    if (maximizing) {
      let best = { score: -Infinity };
      for (let move of moves) {
        chess.move(move);
        let result = minimax(chess, depth - 1, alpha, beta, false);
        chess.undo();
        if (result.score > best.score) {
          best = { score: result.score, move };
        }
        alpha = Math.max(alpha, result.score);
        if (beta <= alpha) break;
      }
      return best;
    } else {
      let best = { score: Infinity };
      for (let move of moves) {
        chess.move(move);
        let result = minimax(chess, depth - 1, alpha, beta, true);
        chess.undo();
        if (result.score < best.score) {
          best = { score: result.score, move };
        }
        beta = Math.min(beta, result.score);
        if (beta <= alpha) break;
      }
      return best;
    }
  } catch (err) {
    console.error('minimax error:', err);
    return { score: 0 };
  }
}

function evaluateBoard(chess) {
  try {
    let score = 0;
    let pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
    for (let i = 0; i < 8; i++) {
      for (let j = 0; j < 8; j++) {
        let square = String.fromCharCode(97 + j) + (8 - i);
        let piece = chess.get(square);
        if (piece) {
          let value = pieceValues[piece.type];
          score += piece.color === 'w' ? value : -value;
        }
      }
    }
    return score;
  } catch (err) {
    console.error('evaluateBoard error:', err);
    return 0;
  }
}

function showPromotionModal() {
  try {
    $('#promotionModal').show();
    $('.piece-option').off('click').on('click', function() {
      if (pendingMove) {
        pendingMove.promotion = $(this).data('piece');
        let result = makeMove(pendingMove);
        if (result !== 'snapback') {
          $('#promotionModal').hide();
          pendingMove = null;
        }
      }
    });
  } catch (err) {
    console.error('showPromotionModal error:', err);
  }
}

function updateGameInfo() {
  try {
    let status = gameStarted ? '' : 'Select a game mode to start';
    if (gameStarted) {
      if (chess.in_checkmate()) {
        status = `Checkmate! ${chess.turn() === 'w' ? 'Black' : 'White'} wins!`;
      } else if (chess.in_check()) {
        status = 'Check!';
      } else if (chess.in_draw()) {
        status = 'Draw!';
      } else {
        status = `${chess.turn() === 'w' ? 'White' : 'Black'} to move`;
      }
    }
    $('#status').text(status);
    $('#playerColor').text(`Your Color: ${playerColor === 'w' ? 'White' : 'Black'}`);
    $('#turn').text(`Turn: ${chess.turn() === 'w' ? 'White' : 'Black'}`);
    $('#whiteTimer').text(`White: ${formatTime(whiteTime)}`);
    $('#blackTimer').text(`Black: ${formatTime(blackTime)}`);
  } catch (err) {
    console.error('updateGameInfo error:', err);
  }
}

function showOnlineMenu() {
  try {
    $('#onlineMenuModal').show();
    updateGameList();
  } catch (err) {
    console.error('showOnlineMenu error:', err);
  }
}

function updateGameList() {
  try {
    $('#gameList').empty();
    availableGames.forEach(game => {
      let gameType = game.isTournament ? 'Tournament' : 'Online Game';
      let item = $(`<div class="game-item" data-game-id="${game.id}">${gameType} ${game.id} - ${game.players} player(s)</div>`);
      item.click(() => joinGame(game.id, game.isTournament));
      $('#gameList').append(item);
    });
  } catch (err) {
    console.error('updateGameList error:', err);
  }
}

function updateTournamentList() {
  try {
    $('#tournamentList').empty();
    if (!availableTournaments || availableTournaments.length === 0) {
      $('#tournamentList').append('<div class="game-item">No active tournaments</div>');
      return;
    }
    availableTournaments.forEach(t => {
      const rounds = t.rounds || 1;
      const timeControl = t.timeControl || { minutes: 10, increment: 0 };
      const name = t.name || t.id;
      const players = t.players || 1;
      let item = $(`
        <div class="game-item" data-tournament-id="${t.id}">
          <strong>${name}</strong> - Players: ${players} - Rounds: ${rounds} - Time: ${timeControl.minutes}+${timeControl.increment}
          <button class="joinTournamentBtn bg-green-500 text-white px-2 py-1 rounded ml-2 hover:bg-green-600">Join</button>
        </div>
      `);
      item.find('.joinTournamentBtn').click(() => {
        ws.send(JSON.stringify({ type: 'joinTournament', tournamentId: t.id }));
        $('#onlineMenuModal').hide();
        $('#tournamentInfo').removeClass('hidden');
        $('#tournamentStatus').text(`Joined Tournament ${name}`);
      });
      $('#tournamentList').append(item);
    });
  } catch (err) {
    console.error('updateTournamentList error:', err);
  }
}

function joinGame(id, isTournament) {
  try {
    gameMode = isTournament ? 'tournament' : 'online';
    gameStarted = true;
    ws.send(JSON.stringify({ type: 'joinGame', gameId: id, isTournament }));
    $('#onlineMenuModal').hide();
    if (isTournament) {
      $('#tournamentInfo').removeClass('hidden');
      $('#tournamentStatus').text(`Joined Tournament ${id}`);
    }
    updateGameInfo();
  } catch (err) {
    console.error('joinGame error:', err);
  }
}

function setupEventListeners() {
  try {
    $('#newGameBtn').click(() => {
      console.log('New Game button clicked');
      chess.reset();
      gameMode = 'computer';
      playerColor = 'w';
      gameStarted = true;
      whiteTime = 600;
      blackTime = 600;
      timeIncrement = 0;
      currentTurn = 'w';
      board.position('start');
      startTimer();
      updateGameInfo();
      $('#promotionModal').hide();
      $('#tournamentInfo').addClass('hidden');
      $('#onlineMenuModal').hide();
    });

    $('#localMultiplayerBtn').click(() => {
      console.log('Local Multiplayer button clicked');
      chess.reset();
      gameMode = 'local';
      playerColor = 'w'; // Default to white, as both sides are played locally
      gameStarted = true;
      whiteTime = 600;
      blackTime = 600;
      timeIncrement = 0;
      currentTurn = 'w';
      board.position('start');
      startTimer();
      updateGameInfo();
      $('#promotionModal').hide();
      $('#tournamentInfo').addClass('hidden');
      $('#onlineMenuModal').hide();
    });

    $('#onlineMultiplayerBtn').click(() => {
      console.log('Online Multiplayer button clicked');
      connectWebSocket();
      showOnlineMenu();
    });

    $('#puzzleModeBtn').click(() => {
      console.log('Puzzle Mode button clicked');
      if (puzzles.length === 0) {
        $('#status').text('Puzzle mode unavailable: No puzzles loaded.');
        return;
      }
      gameStarted = true;
      whiteTime = 600;
      blackTime = 600;
      timeIncrement = 0;
      startPuzzleMode();
      $('#onlineMenuModal').hide();
    });

    $('#tournamentBtn').click(() => {
      console.log('Tournament button clicked');
      $('#tournamentModal').show();
      connectWebSocket();
    });

    $('#closeTournamentModalBtn').click(() => {
      console.log('Close Tournament Modal button clicked');
      $('#tournamentModal').hide();
    });

    $('#createGameBtn').click(() => {
      console.log('Create Game button clicked');
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        $('#status').text('Error: Not connected to server. Please try again.');
        connectWebSocket();
        return;
      }
      const [minutes, increment] = $('#presetSelect').val().split('-').map(Number);
      whiteTime = minutes * 60;
      blackTime = minutes * 60;
      timeIncrement = increment;
      ws.send(JSON.stringify({
        type: 'createGame',
        isTournament: false,
        timeControl: { minutes, increment }
      }));
    });

    $('#closeMenuBtn').click(() => {
      console.log('Close Menu button clicked');
      $('#onlineMenuModal').hide();
    });

    $('#createTournamentForm').submit(function(e) {
      e.preventDefault();
      console.log('Create Tournament form submitted');
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        $('#status').text('Error: Not connected to server. Please try again.');
        connectWebSocket();
        return;
      }
      const minutes = parseInt($('#tournamentMinutes').val());
      const increment = parseInt($('#tournamentIncrement').val());
      whiteTime = minutes * 60;
      blackTime = minutes * 60;
      timeIncrement = increment;
      ws.send(JSON.stringify({
        type: 'createTournament',
        name: $('#tournamentName').val(),
        rounds: parseInt($('#tournamentRounds').val()),
        timeControl: { minutes, increment }
      }));
      $('#tournamentModal').hide();
    });

    $('#pieceThemeSelect').change(function() {
      console.log('Piece theme changed to:', $(this).val());
      const selectedTheme = $(this).val();
      board = Chessboard('chessboard', {
        draggable: true,
        dropOffBoard: 'snapback',
        position: chess.fen(),
        pieceTheme: pieceThemes[selectedTheme],
        onDragStart: onDragStart,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd
      });
      board.resize();
      const boardElement = document.getElementById('chessboard');
      boardElement.addEventListener('touchstart', handleTouchStart, { passive: false });
      boardElement.addEventListener('touchmove', handleTouchMove, { passive: false });
      boardElement.addEventListener('touchend', handleTouchEnd, { passive: false });
    });
  } catch (err) {
    console.error('setupEventListeners error:', err);
  }
}

function startPuzzleMode() {
  try {
    puzzleMode = true;
    if (puzzles.length > 0) {
      currentPuzzle = puzzles[Math.floor(Math.random() * puzzles.length)];
      chess.load(currentPuzzle.fen);
      playerColor = chess.turn();
      board.position(currentPuzzle.fen);
      currentTurn = playerColor;
      updateGameInfo();
      $('#status').text(`Puzzle: Find the best move for ${playerColor === 'w' ? 'White' : 'Black'}`);
    } else {
      console.warn('No puzzles available');
      $('#status').text('No puzzles available. Select another mode.');
      puzzleMode = false;
      gameStarted = false;
    }
  } catch (err) {
    console.error('startPuzzleMode error:', err);
    $('#status').text('Error starting puzzle mode. Select another mode.');
  }
}

function checkPuzzleMove(move) {
  try {
    if (move.san === currentPuzzle.solution) {
      $('#status').text('Correct! Loading next puzzle...');
      setTimeout(startPuzzleMode, 2000);
    } else {
      $('#status').text('Incorrect. Try again.');
      chess.undo();
      board.position(chess.fen);
    }
  } catch (err) {
    console.error('checkPuzzleMove error:', err);
  }
}

function connectWebSocket() {
  try {
    if (ws && ws.readyState === WebSocket.OPEN) {
      console.log('WebSocket already open');
      return;
    }
    ws = new WebSocket('wss://game-hub-fnqa.onrender.com');
    ws.onopen = () => {
      console.log('Connected to WebSocket server');
      ws.send(JSON.stringify({ type: 'fetchLobby' }));
    };
    ws.onmessage = (event) => {
      try {
        let data = JSON.parse(event.data);
        console.log('WebSocket message:', data);
        if (data.type === 'gameCreated') {
          gameId = data.gameId;
          playerColor = data.color || 'w';
          chess.reset();
          board.position('start');
          currentTurn = 'w';
          startTimer();
          updateGameInfo();
          $('#onlineMenuModal').hide();
          $('#status').text(`Game ${gameId} created. Waiting for opponent...`);
        } else if (data.type === 'tournamentCreated') {
          tournamentId = data.tournamentId;
          tournamentActive = true;
          $('#tournamentInfo').removeClass('hidden');
          $('#tournamentStatus').html(`Tournament <strong>${data.tournamentId}</strong> created. Waiting for players...<br>
            <button id="startTournamentBtn" class="bg-blue-500 text-white px-4 py-2 rounded mt-2 w-full hover:bg-blue-600">Start Tournament</button>`);
          $('#onlineMenuModal').hide();
          $('#startTournamentBtn').click(() => {
            ws.send(JSON.stringify({ type: 'startTournament', tournamentId }));
          });
        } else if (data.type === 'tournamentLobbyUpdate') {
          $('#tournamentInfo').removeClass('hidden');
          $('#tournamentStatus').html(
            `Tournament <strong>${data.tournamentId}</strong> Lobby<br>
            Players: ${data.players.map(p => `<span>${p}</span>`).join(', ')}<br>
            ${data.isCreator ? '<button id="startTournamentBtn" class="bg-blue-500 text-white px-4 py-2 rounded mt-2 w-full hover:bg-blue-600">Start Tournament</button>' : ''}`
          );
          if (data.isCreator) {
            $('#startTournamentBtn').click(() => {
              ws.send(JSON.stringify({ type: 'startTournament', tournamentId: data.tournamentId }));
            });
          }
        } else if (data.type === 'opponentJoined' || data.type === 'gameStarted' || data.type === 'gameStart') {
          gameId = data.gameId;
          playerColor = data.color || playerColor;
          chess.reset();
          board.position('start');
          currentTurn = 'w';
          startTimer();
          updateGameInfo();
          $('#status').text(`Game ${gameId} started. You play ${playerColor === 'w' ? 'White' : 'Black'}.`);
        } else if (data.type === 'move') {
          chess.move(data.move);
          board.position(chess.fen());
          currentTurn = chess.turn();
          if (data.time) {
            whiteTime = data.time.white;
            blackTime = data.time.black;
          }
          startTimer();
          updateGameInfo();
        } else if (data.type === 'availableGames' || data.type === 'lobbyData') {
          availableGames = data.games.map(game => ({
            id: game.id,
            players: game.players,
            isTournament: game.isTournament || false,
            timeControl: game.timeControl
          }));
          availableTournaments = data.tournaments.map(t => ({
            id: t.id,
            name: t.name,
            players: t.players,
            rounds: t.rounds,
            timeControl: t.timeControl
          }));
          updateGameList();
          updateTournamentList();
        } else if (data.type === 'opponentDisconnected') {
          $('#status').text('Opponent disconnected. Game ended.');
          gameStarted = false;
          clearInterval(timerInterval);
        }
      } catch (err) {
        console.error('WebSocket message error:', err);
      }
    };
    ws.onclose = () => {
      console.log('Disconnected from WebSocket server');
      $('#status').text('Disconnected from server. Please refresh.');
      clearInterval(timerInterval);
    };
    ws.onerror = (err) => {
      console.error('WebSocket error:', err);
      $('#status').text('WebSocket error. Please refresh.');
      clearInterval(timerInterval);
    };
  } catch (err) {
    console.error('connectWebSocket error:', err);
    $('#status').text('WebSocket connection failed. Please refresh.');
  }
}
</script>
<footer align="center" class="mt-8 text-center text-gray-600">
  <p>&copy; 2025 Strategic Play Chess Game</p>
  <p>Created by NifftySwiggle</p>
</footer>
</body>
</html>
