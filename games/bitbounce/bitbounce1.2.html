<!DOCTYPE html>
<html>
<head>
    <title>BitBounce</title> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Courier New', monospace;
            background-color: #1a1a1a;
            color: #00ff00;
            margin: 0;
            touch-action: none;
            overflow: hidden; /* Prevent scrolling */
        }
        canvas {
            border: 2px solid #00ff00;
            background-color: #000;
            display: block;
            max-width: 100vw;
            max-height: 100vh;
            width: 100%;
            height: auto;
            aspect-ratio: 4 / 5; /* Maintain 400:500 aspect ratio */
            margin: 0;
        }
        #startMenu, #gameOver {
            display: flex;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 2vmin;
            border: 2px solid #00ff00;
            border-radius: 1vmin;
            text-align: center;
            color: #00ff00;
            font-size: 2.5vmin; /* Scale font size */
            max-width: 80vw;
            width: 70vmin;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10;
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
        }
        #gameOver {
            display: none;
        }
        #startMenu {
            display: flex;
        }
        #startMenu h3 {
            font-size: 3.5vmin;
            margin: 1vmin 0;
        }
        #startMenu p, #gameOver p {
            margin: 1vmin 0;
        }
        #leaderboard {
            margin-top: 1vmin;
        }
        button {
            padding: 1.5vmin 3vmin;
            font-size: 2.5vmin;
            cursor: pointer;
            background-color: #00cc00;
            color: #000;
            border: 2px solid #00ff00;
            border-radius: 1vmin;
            margin: 1vmin;
            touch-action: manipulation;
        }
        button:hover {
            background-color: #009900;
        }
        input {
            padding: 1vmin;
            font-size: 2.5vmin;
            margin: 1vmin;
            background-color: #000;
            color: #00ff00;
            border: 1px solid #00ff00;
            width: 80%;
            text-align: center;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="startMenu">
        <h3>How to Play</h3>
        <p><strong>Objective:</strong> Climb as high as possible by jumping on platforms.</p>
        <p><strong>Desktop Controls:</strong><br>
        - Arrow Keys: Move left/right<br>
        - Spacebar: Restart (at game over)</p>
        <p><strong>Mobile Controls:</strong><br>
         Tap/hold left half of screen: Move left<br>
         Tap/hold right half of screen: Move right<br>
         Tap Restart button (at game over)</p>
        <p><strong>Platforms:</strong><br>
         Gray: Standard<br>
         Purple: Temporary (bounce once, then break)<br>
         Cyan: Boost + 300 Points<br>
         Green: Moving</p>
        <p><strong>Created By NifftySwiggle</strong></p>
        <button onclick="startGame()">Start</button>
    </div>
    <div id="gameOver">
        <p>Game Over! Final Score: <span id="finalScore">0</span></p>
        <input type="text" id="playerName" placeholder="Enter your name" maxlength="10">
        <button onclick="saveScore()">Save Score</button>
        <button onclick="restartGame()">Restart</button>
        <ul id="leaderboardList"></ul>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Dynamic canvas sizing
        const aspectRatio = 4 / 5;
        function resizeCanvas() {
            const maxWidth = window.innerWidth;
            const maxHeight = window.innerHeight;
            const width = Math.min(maxWidth, maxHeight * aspectRatio);
            const height = width / aspectRatio;
            canvas.width = width;
            canvas.height = height;
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Initial sizing

        // Scale game elements based on canvas width
        const scaleFactor = canvas.width / 400; // Original width = 400
        const bit = {
            x: canvas.width / 2,
            y: canvas.height - 50 * scaleFactor,
            width: 20 * scaleFactor,
            height: 20 * scaleFactor,
            dy: -10 * scaleFactor,
            gravity: 0.2 * scaleFactor,
            jumpForce: -8.5 * scaleFactor,
            maxDy: 8 * scaleFactor
        };
        const platforms = [];
        let score = 0;
        let gameOver = false;
        let gameStarted = false;
        let keys = { left: false, right: false };
        const particles = [];
        let lastUpdateTime = performance.now();
        const targetFrameTime = 1000 / 60;
        let boostAnimationTime = 0;

        const imagePaths = {
            bit: 'bit.png',
            platform_standard: 'platform_standard.png',
            platform_temporary: 'platform_temporary.png',
            platform_boost: 'platform_boost.png',
            platform_moving: 'platform_standard.png',
            background: 'background.png'
        };
        const images = {};
        let imagesLoaded = 0;
        let totalImages = Object.keys(imagePaths).length;

        Object.keys(imagePaths).forEach(key => {
            images[key] = new Image();
            images[key].onload = () => imagesLoaded++;
            images[key].onerror = () => imagesLoaded++;
            images[key].src = imagePaths[key];
        });

        const platformCount = 5; // Initial number of platforms
        const platformWidth = 60 * scaleFactor;
        const platformHeight = 10 * scaleFactor;
        const platformTypes = ['standard', 'temporary', 'boost', 'moving'];
        const maxHorizontalDistance = 80 * scaleFactor;
        const maxVerticalDistance = 80 * scaleFactor;

        function initPlatforms() {
            platforms.length = 0;
            for (let i = 0; i < platformCount; i++) {
                const type = platformTypes[Math.floor(Math.random() * platformTypes.length)];
                const y = canvas.height - (i * (canvas.height / (platformCount + 2)));
                const x = Math.random() * (canvas.width - platformWidth);
                platforms.push({
                    x: x,
                    y: y,
                    width: platformWidth,
                    height: platformHeight,
                    type: type,
                    dx: type === 'moving' ? (Math.random() > 0.5 ? 2 * scaleFactor : -2 * scaleFactor) : 0
                });
            }
        }

        function loadLeaderboard() {
            const leaderboard = JSON.parse(localStorage.getItem('bitBounceLeaderboard')) || [];
            const leaderboardList = document.getElementById('leaderboardList');
            leaderboardList.innerHTML = '';
            leaderboard.sort((a, b) => b.score - a.score).slice(0, 5).forEach(entry => {
                const li = document.createElement('li');
                li.textContent = `${entry.name}: ${entry.score}`;
                leaderboardList.appendChild(li);
            });
        }

        function saveScore() {
            const name = document.getElementById('playerName').value.trim() || 'Anonymous';
            const leaderboard = JSON.parse(localStorage.getItem('bitBounceLeaderboard')) || [];
            leaderboard.push({ name, score });
            localStorage.setItem('bitBounceLeaderboard', JSON.stringify(leaderboard));
            document.getElementById('playerName').value = '';
            loadLeaderboard();
            restartGame();
        }

        function createParticles(x, y) {
            if (particles.length >= 50) return;
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: x + bit.width / 2,
                    y: y + bit.height,
                    dx: (Math.random() - 0.5) * 4 * scaleFactor,
                    dy: (Math.random() - 0.5) * 4 * scaleFactor,
                    life: 30,
                    size: 6 * scaleFactor
                });
            }
        }

        function startGame() {
            gameStarted = true;
            document.getElementById('startMenu').style.display = 'none';
            initPlatforms();
            canvas.focus();
            lastUpdateTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        let lastTouchUpdate = 0;
        const touchDebounceTime = 16;
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const currentTime = Date.now();
            if (currentTime - lastTouchUpdate < touchDebounceTime) return;
            lastTouchUpdate = currentTime;
            const touch = e.touches[0];
            const canvasRect = canvas.getBoundingClientRect();
            const touchX = (touch.clientX - canvasRect.left) * (canvas.width / canvasRect.width);
            keys.left = touchX < canvas.width / 2;
            keys.right = touchX >= canvas.width / 2;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const currentTime = Date.now();
            if (currentTime - lastTouchUpdate < touchDebounceTime) return;
            lastTouchUpdate = currentTime;
            const touch = e.touches[0];
            const canvasRect = canvas.getBoundingClientRect();
            const touchX = (touch.clientX - canvasRect.left) * (canvas.width / canvasRect.width);
            keys.left = touchX < canvas.width / 2;
            keys.right = touchX >= canvas.width / 2;
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            keys.left = false;
            keys.right = false;
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                keys.left = true;
                e.preventDefault();
            }
            if (e.key === 'ArrowRight') {
                keys.right = true;
                e.preventDefault();
            }
            if (e.key === ' ' && gameOver) {
                e.preventDefault();
                restartGame();
            }
        });
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
        });

        function gameLoop(timestamp) {
            if (!gameStarted || gameOver) return;

            const deltaTime = Math.min(timestamp - lastUpdateTime, 100);
            lastUpdateTime = timestamp;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (images.background.complete && images.background.naturalWidth !== 0) {
                ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            bit.dy += bit.gravity * (deltaTime / targetFrameTime);
            if (bit.dy > bit.maxDy) bit.dy = bit.maxDy;
            bit.y += bit.dy * (deltaTime / targetFrameTime);
            if (keys.left && bit.x > -bit.width) bit.x -= 3 * scaleFactor * (deltaTime / targetFrameTime);
            if (keys.right && bit.x < canvas.width) bit.x += 3 * scaleFactor * (deltaTime / targetFrameTime);
            if (bit.x + bit.width < 0) bit.x += canvas.width;
            if (bit.x > canvas.width) bit.x -= canvas.width;

            if (images.bit.complete && images.bit.naturalWidth !== 0) {
                ctx.drawImage(images.bit, bit.x, bit.y, bit.width, bit.height);
            } else {
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(bit.x, bit.y, bit.width, bit.height);
            }

            let boostTriggered = false;
            platforms.forEach((p, i) => {
                if (p.type === 'moving') {
                    p.x += p.dx * (deltaTime / targetFrameTime);
                    if (p.x < 0) {
                        p.x = 0;
                        p.dx = -p.dx;
                    }
                    if (p.x > canvas.width - p.width) {
                        p.x = canvas.width - p.width;
                        p.dx = -p.dx;
                    }
                }

                if (
                    bit.dy > 0 &&
                    bit.y + bit.height > p.y &&
                    bit.y + bit.height < p.y + p.height + 10 * scaleFactor &&
                    bit.x + bit.width > p.x &&
                    bit.x < p.x + p.width
                ) {
                    if (p.type === 'temporary') {
                        bit.dy = bit.jumpForce;
                        platforms.splice(i, 1);
                    } else {
                        bit.dy = p.type === 'boost' ? bit.jumpForce * 1.25 : bit.jumpForce;
                        if (p.type === 'boost') {
                            createParticles(bit.x, bit.y);
                            boostTriggered = true;
                            boostAnimationTime = 300;
                        }
                    }
                }

                const imgKey = p.type === 'moving' ? 'platform_moving' : `platform_${p.type}`;
                if (images[imgKey] && images[imgKey].complete && images[imgKey].naturalWidth !== 0) {
                    ctx.drawImage(images[imgKey], p.x, p.y, p.width, p.height);
                } else {
                    ctx.fillStyle = p.type === 'temporary' ? '#800080' : p.type === 'boost' ? '#00ffff' : p.type === 'moving' ? '#32cd32' : '#808080';
                    ctx.fillRect(p.x, p.y, p.width, p.height);
                }
            });

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.dx * (deltaTime / targetFrameTime);
                p.y += p.dy * (deltaTime / targetFrameTime);
                p.life--;
                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.fillStyle = `rgba(0, 255, 255, ${p.life / 30})`;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                }
            }

            if (bit.y < canvas.height / 2) {
                const offset = (canvas.height / 2 - bit.y) / 8 * (deltaTime / targetFrameTime);
                bit.y += offset;
                platforms.forEach(p => p.y += offset);
                const scoreIncrement = Math.floor(offset);
                score = Math.min(score + scoreIncrement, 999999);
            }

            const highestPlatform = platforms.reduce((highest, p) => p.y < highest.y ? p : highest, { y: canvas.height });
            if (highestPlatform.y > maxVerticalDistance * 0.8) {
                const type = platformTypes[Math.floor(Math.random() * platformTypes.length)];
                const newX = Math.random() * (canvas.width - platformWidth);
                const newY = highestPlatform.y - maxVerticalDistance * (0.5 + Math.random() * 0.5);
                platforms.push({
                    x: newX,
                    y: newY,
                    width: platformWidth,
                    height: platformHeight,
                    type: type,
                    dx: type === 'moving' ? (Math.random() > 0.5 ? 2 * scaleFactor : -2 * scaleFactor) : 0
                });
            }

            for (let i = platforms.length - 1; i >= 0; i--) {
                const p = platforms[i];
                if (p.y > canvas.height) {
                    platforms.splice(i, 1);
                    const type = platformTypes[Math.floor(Math.random() * platformTypes.length)];
                    const newX = Math.random() * (canvas.width - platformWidth);
                    const newY = highestPlatform.y - maxVerticalDistance * (0.5 + Math.random() * 0.5);
                    platforms.push({
                        x: newX,
                        y: newY,
                        width: platformWidth,
                        height: platformHeight,
                        type: type,
                        dx: type === 'moving' ? (Math.random() > 0.5 ? 2 * scaleFactor : -2 * scaleFactor) : 0
                    });
                }
            }

            // Draw title and score last to ensure top layer
            ctx.save();
            ctx.font = `${24 * scaleFactor}px Courier New`;
            ctx.fillStyle = '#00ff00';
            ctx.textAlign = 'center';
            ctx.fillText('BitBounce', canvas.width / 2, 30 * scaleFactor);

            ctx.font = `${18 * scaleFactor}px Courier New`;
            let scoreScale = 1;
            if (boostAnimationTime > 0) {
                scoreScale = 1 + 0.2 * Math.sin((boostAnimationTime / 300) * Math.PI);
                boostAnimationTime -= deltaTime;
            }
            ctx.scale(scoreScale, scoreScale);
            ctx.fillText(`Score: ${score}`, canvas.width / (2 * scoreScale), (50 * scaleFactor) / scoreScale);
            ctx.restore();

            if (bit.y > canvas.height) endGame();

            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameOver = true;
            document.getElementById('gameOver').style.display = 'flex';
            document.getElementById('finalScore').innerText = score;
            loadLeaderboard();
            canvas.focus();
            document.getElementById('playerName').focus();
        }

        function restartGame() {
            bit.x = canvas.width / 2;
            bit.y = canvas.height - 50 * scaleFactor;
            bit.dy = -10 * scaleFactor;
            platforms.length = 0;
            particles.length = 0;
            score = 0;
            gameOver = false;
            gameStarted = true;
            boostAnimationTime = 0;
            document.getElementById('gameOver').style.display = 'none';
            initPlatforms();
            canvas.focus();
            lastUpdateTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        loadLeaderboard();
        canvas.focus();
    </script>
</body>
</html>